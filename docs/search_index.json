[
["uploads-and-downloads.html", "Chapter 9 Uploads and Downloads", " Chapter 9 Uploads and Downloads This chapter is in development... Exercise 9.4.1 Use the ambient package by Thomas Lin Pedersen to generate worley noise and download a PNG of it. Solution A general method for saving a PNG is to select the png driver using the function png(). The only argument the driver needs is the name of the plot (this will be stored relative to your current working directory!). You will not see the plot when running the plot function because it is being saved to the file instead. When we’re done plotting, we used the dev.off() command to close the connection to the driver. library(ambient) noise &lt;- ambient::noise_worley(c(100, 100)) png(&quot;noise_plot.png&quot;) plot(as.raster(normalise(noise))) dev.off() Exercise 9.4.2 Create an app that lets you upload a csv file, select a variable, and then perform a t.test() on that variable. After the user has uploaded the csv file, you’ll need to use updateSelectInput() to fill in the available variables. See Section 10.1 for details. Solution We can use the fileInput widget and the accept argument to ensure our app only takes on .csvs. In the server function we’ll select the datapath from within our file input and use this to update our selectInput. We need to put the updateSelectInput within a reactive because we need the options to change if the user selects another file. Lastly, we use input$variable to create our t-test output. library(shiny) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( fileInput(&quot;file&quot;, &quot;Upload CSV&quot;, accept = &quot;.csv&quot;), # file widget selectInput(&quot;variable&quot;, &quot;Select Variable&quot;, choices = NULL) # select widget ), mainPanel( verbatimTextOutput(&quot;results&quot;) # t-test results ) ) ) server &lt;- function(input, output,session) { # get data from file data &lt;- reactive({ req(input$file) # as shown in the book, lets make sure the uploaded file is a csv ext &lt;- tools::file_ext(input$file$name) validate(need(ext == &quot;csv&quot;, &quot;Invalid file. Please upload a .csv file&quot;)) dataset &lt;- vroom::vroom(input$file$datapath, delim = &quot;,&quot;) # let the user know if the data contains no numeric column validate(need(ncol(dplyr::select_if(dataset, is.numeric)) != 0, &quot;This dataset has no numeric columns.&quot;)) dataset }) # create the select input based on the numeric columns in the dataframe observeEvent(input$file, { req(data()) num_cols &lt;- dplyr::select_if(data(), is.numeric) updateSelectInput(session, &quot;variable&quot;, choices = colnames(num_cols)) }) # print t-test results output$results &lt;- renderPrint({ if(!is.null(input$variable)) t.test(data()[input$variable]) }) } shinyApp(ui, server) Exercise 9.4.3 Create an app that lets the user upload a csv file, select one variable, draw a histogram, and then download the histogram. For an additional challenge, allow the user to select from .png, .pdf, and .svg output formats. Solution Adapting the code from the example above, rather than print a t-test output, we create a plot reactive to use in the UI’s output$results and to use within our downloadHander. We can use the ggsave function to switch between input$extension types. library(shiny) library(ggplot2) ui &lt;- fluidPage( tagList( br(), br(), column(4, wellPanel( fileInput(&quot;file&quot;, &quot;Select CSV&quot;, accept = &quot;.csv&quot;), # file widget selectInput(&quot;variable&quot;, &quot;Select Variable&quot;, choices = NULL), # select widget ), wellPanel( radioButtons(&quot;extension&quot;, &quot;Save As:&quot;, choices = c(&quot;png&quot;, &quot;pdf&quot;, &quot;svg&quot;), inline = TRUE), downloadButton(&quot;download&quot;, &quot;Save Plot&quot;) ) ), column(8, plotOutput(&quot;results&quot;)) ) ) server &lt;- function(input, output,session) { # get data from file data &lt;- reactive({ req(input$file) read.csv(input$file$datapath) }) # create the select input based on the numeric columns in the dataframe observeEvent( input$file, { num_cols &lt;- dplyr::select_if(data(), is.numeric) updateSelectInput(session, &quot;variable&quot;, choices = colnames(num_cols)) }) # plot histogram plot_output &lt;- reactive({ req(!is.null(input$variable)) ggplot(data()) + aes_string(x = input$variable) + geom_histogram() }) output$results &lt;- renderPlot(plot_output()) # save histogram using downloadHandler and plot output type output$download &lt;- downloadHandler( filename = paste0(&quot;histogram.&quot;, input$extension), content = function(file){ ggsave(file, plot_output(), device = input$extension) } ) } shinyApp(ui = ui, server = server) Exercise 9.4.4 Write an app that allows the user to create a Lego mosaic from any .png file using Ryan Timpe’s brickr package. Once you’ve completed the basics, add controls to allow the user to select the size of the mosaic (in bricks), and choose whether to use “universal” or “generic” colour palettes. Solution Instead of limiting our file selection to a csv as above, here we are going to limit our input to a png. We’ll use the png::readPNG function to read in our file, and specify the size and color of our mosaic in brickr’s image_to_mosaic function. Read more about the package and examples here library(shiny) library(brickr) library(png) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( fluidRow( fileInput(&quot;myFile&quot;, &quot;Choose a file&quot;, accept = c(&#39;image/png&#39;)), sliderInput(&quot;size&quot;, &quot;Select Size:&quot;, min = 1, max = 100, value = 35), radioButtons(&quot;color&quot;, &quot;Select Color Palette:&quot;, choices = c(&quot;universal&quot;, &quot;generic&quot;)) ) ), mainPanel(plotOutput(&quot;result&quot;)) ) ) server &lt;- function(input, output) { observeEvent(input$myFile, { inFile &lt;- input$myFile if (is.null(inFile)) return() output$result &lt;- renderPlot({ png::readPNG(inFile$datapath) %&gt;% image_to_mosaic(img_size = input$size, color_palette = input$color) %&gt;% build_mosaic() }) }) } shinyApp(ui = ui, server = server) "]
]
